using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Kodify.AutoDoc.Models;
using Kodify.AI.Services;
using LibGit2Sharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;
using System.Reflection;

namespace Kodify.AutoDoc.Services
{
    public class MarkdownGenerator
    {
        private readonly OpenAIService _aiService;

        public MarkdownGenerator(OpenAIService aiService)
        {
            _aiService = aiService;
        }

        public async Task GenerateReadMe(
            ProjectInfo projectInfo,
            string projectName,
            string projectSummary,
            string usageInstructions,
            string template = null)
        {
            var rootPath = DetectProjectRoot(projectInfo.ProjectPath);
            var outputPath = Path.Combine(rootPath, "README.md");
            await GenerateReadMe(projectInfo, outputPath, projectName, projectSummary, usageInstructions, template);
        }

        public void GenerateChangelog()
        {
            var rootPath = DetectProjectRoot();
            var outputPath = Path.Combine(rootPath, "CHANGELOG.md");
            GenerateChangelog(outputPath);
        }

        private string DetectProjectRoot(string startPath = null)
        {
            var directory = new DirectoryInfo(startPath ?? Directory.GetCurrentDirectory());
            DirectoryInfo trueRoot = null;

            // First check for Git repository root
            try
            {
                var repoPath = Repository.Discover(directory.FullName);
                if (!string.IsNullOrEmpty(repoPath))
                {
                    using var repo = new Repository(repoPath);
                    trueRoot = new DirectoryInfo(repo.Info.WorkingDirectory);
                }
            }
            catch { }

            // If Git root not found, look for solution/project files
            if (trueRoot == null)
            {
                var currentDir = directory;
                while (currentDir != null)
                {
                    if (currentDir.GetFiles().Any(f => f.Extension == ".sln" || f.Extension == ".csproj"))
                    {
                        trueRoot = currentDir;
                        break;
                    }
                    currentDir = currentDir.Parent;
                }
            }

            return trueRoot?.FullName ?? 
                throw new DirectoryNotFoundException("Project root not found");
        }

        public async Task GenerateReadMe(
            ProjectInfo projectInfo,
            string outputPath,
            string projectName,
            string projectSummary,
            string usageInstructions,
            string template = null)
        {
            try
            {
                Directory.CreateDirectory(Path.GetDirectoryName(outputPath));

                using (var writer = new StreamWriter(outputPath))
                {
                    string finalContent;

                    if (!string.IsNullOrEmpty(template))
                    {
                        var readmeContent = BuildManualContent(projectInfo, projectName, projectSummary, usageInstructions);
                        finalContent = await _aiService.EnhanceDocumentationAsync(template, readmeContent);
                    }
                    else
                    {
                        var structuredContent = GetStructuredContent(projectInfo);
                        finalContent = await _aiService.GenerateDocumentationAsync(
                            projectName,
                            projectSummary,
                            usageInstructions,
                            structuredContent,
                            projectInfo.HasWebApi, projectInfo.License);
                    }

                    writer.WriteLine(finalContent);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error generating markdown: {ex.Message}");
                throw;
            }
        }

        private string GetStructuredContent(ProjectInfo projectInfo)
        {
            var sb = new StringBuilder();

            // Only show API status if detected
            if (projectInfo.HasWebApi)
            {
                sb.AppendLine("### Technical Overview");
                sb.AppendLine($"- API Detected: Yes");
            }

            // Filter out autogenerated files
            var filteredFiles = projectInfo.SourceFiles
                .Where(f => !IsAutogeneratedFile(f.FilePath))
                .ToList();

            if (filteredFiles.Any())
            {
                sb.AppendLine("\n### Key Features");
                sb.AppendLine("- Interactive user interface");
                sb.AppendLine("- Responsive design");
                sb.AppendLine("- Cross-browser compatibility");
            }

            sb.AppendLine($"License Status: {projectInfo.License.Type}");
            if (projectInfo.License.Type != "None")
            {
                sb.AppendLine($"License File: {Path.GetFileName(projectInfo.License.FilePath)}");
            }

            return sb.ToString();
        }

        private bool IsAutogeneratedFile(string filePath)
        {
            var excludedFiles = new[]
            {
        "AssemblyInfo.cs",
        "GlobalUsings.g.cs",
        ".NETCoreApp,Version"
    };

            return excludedFiles.Any(e => filePath.Contains(e));
        }

        private List<string> BuildManualContent(
            ProjectInfo projectInfo,
            string projectName,
            string projectSummary,
            string usageInstructions)
        {
            var content = new List<string>
            {
                $"# {projectName}",
                $"![Build Status](https://img.shields.io/badge/build-passing-brightgreen)",
                GetLicenseBadge(projectInfo.License),
                projectSummary,
                "",
                "## Table of Contents",
                "- [Features](#features)",
                "- [Installation](#installation)",
                "- [Usage](#usage)",
                "- [Project Structure](#project-structure)",
                "- [API Reference](#api-reference)",
                "- [Contributing](#contributing)",
                "- [License](#license)",
                "",
                "## Features"
            };

            // Dynamic feature detection
            content.AddRange(DetectFeatures(projectInfo));
            content.Add("");

            // Installation section
            content.AddRange(GetInstallationInstructions(projectInfo));
            content.Add("");

            // Usage section
            content.AddRange(GetUsageInstructions(usageInstructions, projectInfo));
            content.Add("");

            // Project Structure
            content.Add("## Project Structure");
            content.Add("```");
            content.AddRange(projectInfo.Structure.Directories
                .Select(d => d.Replace(projectInfo.ProjectPath, "")));
            content.Add("```");
            content.Add("");

            // API Reference
            if (projectInfo.HasWebApi)
            {
                content.Add("## API Reference");
                content.AddRange(GenerateApiReference(projectInfo));
                content.Add("");
            }

            // Standard sections
            content.AddRange(new[]
            {
                "## Contributing",
                "1. Fork the Project",
                "2. Create your Feature Branch",
                "3. Commit your Changes",
                "4. Push to the Branch",
                "5. Open a Pull Request",
                "",
            });

            content.AddRange(GetContributionSection(projectInfo));
            content.Add("");

            content.AddRange(GetLicenseSection(projectInfo.License));

            return content;
        }

        private IEnumerable<string> DetectFeatures(ProjectInfo projectInfo)
        {
            var features = new List<string>();

            // Detect architectural features
            if (projectInfo.SourceFiles.Any(f => f.FilePath.Contains("Services")))
                features.Add("- Service layer architecture");

            if (projectInfo.SourceFiles.Any(f => f.FilePath.Contains("Repositories")))
                features.Add("- Database repository pattern");

            // Detect testing framework
            if (projectInfo.SourceFiles.Any(f => f.FilePath.EndsWith("Tests.cs")))
                features.Add("- Unit test coverage");

            // Detect web features
            if (projectInfo.SourceFiles.Any(f => f.FilePath.Contains("Controllers")))
                features.Add("- Web API endpoints");

            // Fallback if no features detected
            if (!features.Any())
            {
                features.Add("- Clean architecture");
                features.Add("- Modern development practices");
                features.Add("- Comprehensive documentation");
            }

            return features;
        }

        private IEnumerable<string> GetInstallationInstructions(ProjectInfo projectInfo)
        {
            var (hasGit, repoUrl) = CheckForGitRepository(projectInfo.ProjectPath);
            var instructions = new List<string> { "## Installation" };

            if (hasGit && !string.IsNullOrEmpty(repoUrl))
            {
                instructions.Add($"```bash\ngit clone {repoUrl}\ncd {Path.GetFileName(projectInfo.ProjectPath)}");
            }
            else
            {
                instructions.Add("```bash\n# Download the source code\ncurl -L [SOURCE_URL] -o project.zip\nunzip project.zip");
            }

            instructions.Add("dotnet restore");

            if (File.Exists(Path.Combine(projectInfo.ProjectPath, "Dockerfile")))
            {
                instructions.Add("docker build -t myapp .");
            }

            instructions.Add("```");

            return instructions;
        }


        private string GetRepositoryUrl(ProjectInfo projectInfo)
        {
            try
            {
                var repoPath = Repository.Discover(projectInfo.ProjectPath);
                using var repo = new Repository(repoPath);
                return repo.Network.Remotes.FirstOrDefault()?.Url ?? "No remote repository configured";
            }
            catch
            {
                return "No Git repository found";
            }
        }

        private IEnumerable<string> GetUsageInstructions(string usageInstructions, ProjectInfo projectInfo)
        {
            var usage = new List<string>
            {
                "## Usage",
                usageInstructions
            };

            // Find a representative class
            var sampleClass = projectInfo.SourceFiles
                .SelectMany(f => f.Classes)
                .FirstOrDefault(c => c.Methods.Any());

            if (sampleClass != null)
            {
                usage.Add("```csharp");
                usage.Add($"var service = new {sampleClass.Name}();");
                if (sampleClass.Methods.Any())
                    usage.Add($"service.{sampleClass.Methods.First().Name}();");
                usage.Add("```");
            }

            return usage;
        }

        private IEnumerable<string> GenerateApiReference(ProjectInfo projectInfo)
        {
            if (!projectInfo.HasWebApi) return Enumerable.Empty<string>();

            var apiContent = new List<string>();

            foreach (var file in projectInfo.SourceFiles)
            {
                foreach (var controller in file.Classes.Where(c => c.IsApiController))
                {
                    apiContent.Add($"### {controller.Name.Replace("Controller", "")}");

                    foreach (var method in controller.Methods)
                    {
                        if (!method.Attributes.Any(a => a.StartsWith("Http"))) continue;

                        var httpMethod = method.Attributes.First(a => a.StartsWith("Http"));
                        apiContent.Add($"- `{httpMethod} {method.Name}`");
                    }
                }
            }

            return apiContent.Any()
                ? new[] { "## API Reference" }.Concat(apiContent)
                : Enumerable.Empty<string>();
        }
        private string DetectHttpMethod(Kodify.AutoDoc.Models.MethodInfo method)
        {
            var httpMethods = new[] { "HttpGet", "HttpPost", "HttpPut", "HttpDelete", "HttpPatch" };
            var methodAttribute = method.Attributes.FirstOrDefault(a => httpMethods.Contains(a));
            return methodAttribute?.Replace("Http", "") ?? "GET"; // Default to GET
        }

        private string DetectRouteTemplate(ClassInfo controller, Kodify.AutoDoc.Models.MethodInfo method)
        {
            var controllerRoute = controller.Attributes
                .FirstOrDefault(a => a.StartsWith("Route("))?
                .Split('"').ElementAtOrDefault(1) ?? "";

            var methodRoute = method.Attributes
                .FirstOrDefault(a => a.StartsWith("Route("))?
                .Split('"').ElementAtOrDefault(1) ?? "";

            return $"/{controllerRoute.Trim('/')}/{methodRoute.Trim('/')}".Trim('/');
        }

        private string GetCodeContent(ProjectInfo projectInfo)
        {
            var codeContents = new List<string>();
            foreach (var file in projectInfo.SourceFiles)
            {
                try
                {
                    codeContents.Add(File.ReadAllText(file.FilePath));
                }
                catch
                {
                    // Handle unreadable files
                }
            }
            return string.Join("\n\n", codeContents);
        }

        private string GetLicenseBadge(LicenseInfo license)
        {
            var licenseType = license.Type switch
            {
                "MIT" => "MIT",
                "Apache-2.0" => "Apache%202.0",
                "GPL-3.0" => "GPL%203.0",
                "MPL-2.0" => "MPL%202.0",
                "Unlicense" => "Unlicense",
                "Custom" => "Custom",
                _ => "None"
            };

            return $"![License](https://img.shields.io/badge/license-{licenseType}-blue)";
        }

        private IEnumerable<string> GetLicenseSection(LicenseInfo license)
        {
            var section = new List<string>
    {
        "## License"
    };

            if (license.Type == "None")
            {
                section.Add("This project currently does not have a license. " +
                            "Please contact the maintainers for usage permissions.");
            }
            else if (license.Type == "Custom")
            {
                section.Add("Custom license - see [LICENSE](LICENSE) file for details.");
            }
            else
            {
                section.Add($"Distributed under the {license.Type} License. " +
                           $"See [LICENSE]({Path.GetFileName(license.FilePath)}) for more information.");
            }

            return section;
        }

        public void GenerateChangelog(string outputPath)
        {
            try
            {
                Directory.CreateDirectory(Path.GetDirectoryName(outputPath));

                using (var writer = new StreamWriter(outputPath))
                {
                    writer.WriteLine("# Changelog");

                    var repoPath = Repository.Discover(Path.GetDirectoryName(outputPath));
                    if (repoPath == null)
                    {
                        writer.WriteLine("No Git repository found.");
                        return;
                    }

                    using (var repo = new Repository(repoPath))
                    {
                        var tags = repo.Tags
                            .Where(t => t.IsAnnotated)
                            .OrderByDescending(t => ((Commit)t.Target).Committer.When)
                            .ToList();

                        if (!tags.Any())
                        {
                            writer.WriteLine("## Unreleased");
                            foreach (var c in repo.Commits)
                            {
                                writer.WriteLine($"- {c.MessageShort} ({c.Sha[..7]})");
                            }
                            return;
                        }

                        foreach (var tag in tags)
                        {
                            var commit = (Commit)tag.Target;
                            writer.WriteLine($"## {tag.FriendlyName} ({commit.Committer.When:yyyy-MM-dd})");
                            writer.WriteLine();

                            var previousTag = tags.ElementAtOrDefault(tags.IndexOf(tag) + 1);
                            var filter = new CommitFilter
                            {
                                IncludeReachableFrom = commit,
                                ExcludeReachableFrom = previousTag?.Target
                            };

                            var commitsInRange = repo.Commits.QueryBy(filter).ToList();
                            if (!commitsInRange.Any())
                            {
                                writer.WriteLine("- No changes recorded");
                            }
                            else
                            {
                                foreach (var c in commitsInRange)
                                {
                                    writer.WriteLine($"- {c.MessageShort} ({c.Sha[..7]})");
                                }
                            }
                            writer.WriteLine();
                        }

                        writer.WriteLine("## Unreleased");
                        writer.WriteLine();
                        var lastTag = tags.Last().Target;
                        var unreleasedFilter = new CommitFilter
                        {
                            IncludeReachableFrom = repo.Head.Tip,
                            ExcludeReachableFrom = lastTag
                        };

                        foreach (var c in repo.Commits.QueryBy(unreleasedFilter))
                        {
                            writer.WriteLine($"- {c.MessageShort} ({c.Sha[..7]})");
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error generating changelog: {ex.Message}");
            }
        }


        private IEnumerable<string> GetContributionSection(ProjectInfo projectInfo)
        {
            var section = new List<string> { "## Contributing" };

            var (hasGit, repoUrl) = CheckForGitRepository(projectInfo.ProjectPath);

            if (hasGit)
            {
                section.Add("Contributions are welcome! Here's how to get started:");
                section.Add("");
                section.Add($"1. **Clone the repository**  \n`git clone {repoUrl}`");
                section.Add($"2. **Create a branch**  \n`git checkout -b feature/your-feature`");
                section.Add("3. **Commit changes**  \n`git commit -m 'Add awesome feature'`");
                section.Add("4. **Push to branch**  \n`git push origin feature/your-feature`");
                section.Add("5. **Open a pull request**");

                if (repoUrl.Contains("github.com"))
                {
                    section.Add("");
                    section.Add($"Visit the [GitHub repository]({repoUrl}) to view open issues.");
                }
            }
            else
            {
                section.Add("To contribute to this project:");
                section.Add("1. Contact the maintainers for access");
                section.Add("2. Follow internal collaboration guidelines");
                section.Add("3. Submit changes via approved channels");
            }

            return section;
        }

        private (bool HasGit, string Url) CheckForGitRepository(string projectPath)
        {
            try
            {
                var repoPath = Repository.Discover(projectPath);
                if (string.IsNullOrEmpty(repoPath)) return (false, null);

                using var repo = new Repository(repoPath);
                var remote = repo.Network.Remotes.FirstOrDefault(r => r.Name == "origin");

                if (remote == null) return (true, null);

                var url = NormalizeGitUrl(remote.Url);
                return (true, url);
            }
            catch
            {
                return (false, null);
            }
        }

        private string NormalizeGitUrl(string gitUrl)
        {
            // Convert SSH URL to HTTPS
            if (gitUrl.StartsWith("git@"))
            {
                return gitUrl
                    .Replace("git@github.com:", "https://github.com/")
                    .Replace("git@gitlab.com:", "https://gitlab.com/")
                    .Replace(".git", "");
            }

            return gitUrl;
        }
    }
}